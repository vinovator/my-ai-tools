<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anthropic Productivity Patterns - Set 3 (Xenographics)</title>
    <style>
        :root {
            --bg: #050505;
            /* Void Black */
            --card: #111;
            --text: #f0f0f0;
            --accent-cyan: #06b6d4;
            /* Cyber Cyan */
            --accent-lime: #84cc16;
            /* Acid Lime */
            --accent-pink: #f472b6;
            /* Hot Pink */
            --font: 'Courier New', Courier, monospace;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--font);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        header {
            padding: 3rem 1rem;
            text-align: center;
            border-bottom: 1px solid #222;
            width: 100%;
            margin-bottom: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-pink));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            color: #888;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 2rem;
            padding: 0 1rem;
        }

        button {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #888;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-family: var(--font);
            font-size: 0.8rem;
            text-transform: uppercase;
        }

        button:hover {
            border-color: var(--accent-cyan);
            color: #fff;
        }

        button.active {
            background: var(--accent-cyan);
            color: #000;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 15px rgba(6, 182, 212, 0.4);
            font-weight: bold;
        }

        /* Toggle */
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .switch {
            width: 60px;
            height: 30px;
            background: #222;
            border: 1px solid #444;
            cursor: pointer;
            position: relative;
        }

        .switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 24px;
            height: 24px;
            background: #666;
            transition: 0.2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .switch.on {
            border-color: var(--accent-lime);
        }

        .switch.on::after {
            transform: translateX(30px);
            background: var(--accent-lime);
            box-shadow: 0 0 10px var(--accent-lime);
        }

        /* Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            width: 90%;
            max-width: 1400px;
            padding-bottom: 4rem;
        }

        .card {
            background: var(--card);
            border: 1px solid #333;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-cyan), transparent);
            opacity: 0.5;
        }

        .card h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1.1rem;
            color: var(--text);
            font-weight: 400;
        }

        .card .meta {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 1rem;
            height: 3em;
            line-height: 1.4;
        }

        canvas {
            width: 100%;
            height: 280px;
            background: #000;
            border: 1px solid #222;
            margin-top: auto;
        }
    </style>
</head>

<body>

    <header>
        <h1>Xenographic Productivity</h1>
        <p>Visualization Set 3: High-Dimensional Workflows</p>
    </header>

    <div class="toggle-wrapper">
        <span>Standard Human</span>
        <div class="switch" id="mainToggle"></div>
        <span style="color: var(--accent-lime);">AI Enhanced</span>
    </div>

    <div class="controls">
        <button class="active" onclick="setTab(0)">1. Fractal Reach</button>
        <button onclick="setTab(1)">2. Hyper-Learning</button>
        <button onclick="setTab(2)">3. Entropy Reversal</button>
    </div>

    <div class="grid" id="grid"></div>

    <script>
        // --- STATE ---
        let isAI = false;
        let activeTab = 0;

        // Colors
        const C_BG = '#000000';
        const C_CYAN = '#06b6d4';
        const C_LIME = '#84cc16';
        const C_PINK = '#f472b6';
        const C_GREY = '#333333';

        document.getElementById('mainToggle').addEventListener('click', function () {
            isAI = !isAI;
            this.classList.toggle('on', isAI);
        });

        const setTab = (idx) => {
            activeTab = idx;
            document.querySelectorAll('.controls button').forEach((b, i) => b.classList.toggle('active', i === idx));
            renderGrid();
        };

        const renderGrid = () => {
            const grid = document.getElementById('grid');
            grid.innerHTML = ''; // This removes old canvases, making them disconnected

            const patterns = [
                // TAB 1: FULL STACK (Fractal/Growth)
                [
                    { title: "The Fractal Tree", desc: "Depth of capability. Human branches once. AI recursively branches into deep specialized knowledge.", fn: initFractal },
                    { title: "Voronoi Territory", desc: "Project ownership. AI optimizes cell distribution to cover 100% of the problem space.", fn: initVoronoi },
                    { title: "Strata Drill", desc: "Vertical integration. Cutting through layers of the stack. AI drills with laser precision.", fn: initDrill }
                ],
                // TAB 2: LEARNING (Physics)
                [
                    { title: "Particle Collider", desc: "Idea synthesis. High-energy collisions generate new exotic particles (solutions) faster.", fn: initCollider },
                    { title: "Evolutionary Grid", desc: "Iteration speed. An accelerated Game of Life. AI converges to stable patterns instantly.", fn: initEvo },
                    { title: "Harmonic Resonator", desc: "Signal amplification. AI tunes the frequency to create perfect constructive interference.", fn: initResonator }
                ],
                // TAB 3: NEGLECTED TASKS (Restoration)
                [
                    { title: "Rust Scrubber", desc: "Technical debt. A high-speed rotary scrubber removing alpha transparency (grime).", fn: initScrubber },
                    { title: "Thread Weaver", desc: "Disorganized inputs. AI creates a loom that sorts chaotic strands into orderly parallel lines.", fn: initWeaver },
                    { title: "The Omni-Light", desc: "Observability. Revealing the map. Human uses a torch; AI uses a flare.", fn: initLight }
                ]
            ];

            patterns[activeTab].forEach(p => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `<h3>${p.title}</h3><div class="meta">${p.desc}</div><canvas></canvas>`;
                grid.appendChild(card);

                const canvas = card.querySelector('canvas');
                const rect = card.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                canvas.width = (rect.width - 50) * dpr;
                canvas.height = 280 * dpr;

                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);

                // Start animation with context
                p.fn(ctx, canvas.width / dpr, canvas.height / dpr);
            });
        };

        // --- ANIMATIONS ---

        // Helper to check stop condition
        const isRunning = (ctx) => ctx.canvas.isConnected;

        // 1. FRACTAL TREE
        const initFractal = (ctx, w, h) => {
            let frame = 0;
            const drawTree = (x, y, len, angle, depth) => {
                ctx.beginPath();
                ctx.moveTo(x, y);
                const x2 = x + Math.cos(angle) * len;
                const y2 = y + Math.sin(angle) * len;
                ctx.lineTo(x2, y2);

                ctx.strokeStyle = `hsl(${(frame + depth * 20) % 360}, 70%, 60%)`;
                if (!isAI && depth > 2) ctx.strokeStyle = '#333';

                ctx.lineWidth = depth * 0.5;
                ctx.stroke();

                if (depth > 0) {
                    if (!isAI && depth < 3) return;
                    const spread = isAI ? 0.5 + Math.sin(frame * 0.02) * 0.1 : 0.3;
                    drawTree(x2, y2, len * 0.7, angle - spread, depth - 1);
                    drawTree(x2, y2, len * 0.7, angle + spread, depth - 1);
                }
            };

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(0, 0, w, h);
                frame++;

                const maxDepth = isAI ? 9 : 4;
                const len = isAI ? 50 : 60;
                drawTree(w / 2, h, len, -Math.PI / 2, maxDepth);

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 2. VORONOI TERRITORY
        const initVoronoi = (ctx, w, h) => {
            const points = Array(15).fill().map(() => ({
                x: Math.random() * w,
                y: Math.random() * h,
                vx: (Math.random() - 0.5),
                vy: (Math.random() - 0.5)
            }));

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.clearRect(0, 0, w, h);

                if (isAI) {
                    for (let i = 0; i < points.length; i++) {
                        for (let j = i + 1; j < points.length; j++) {
                            const dx = points[i].x - points[j].x;
                            const dy = points[i].y - points[j].y;
                            const d = Math.hypot(dx, dy);
                            if (d < 100 && d > 1) { // Prevent div by zero
                                points[i].x += dx / d; points[i].y += dy / d;
                                points[j].x -= dx / d; points[j].y -= dy / d;
                            }
                        }
                    }
                }

                points.forEach(p => {
                    p.x += p.vx; p.y += p.vy;
                    if (p.x < 0 || p.x > w) p.vx *= -1;
                    if (p.y < 0 || p.y > h) p.vy *= -1;

                    ctx.fillStyle = isAI ? C_CYAN : C_GREY;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
                });

                ctx.strokeStyle = isAI ? '#164e63' : '#262626';
                ctx.beginPath();
                for (let i = 0; i < points.length; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        if (Math.hypot(points[i].x - points[j].x, points[i].y - points[j].y) < 100) {
                            ctx.moveTo(points[i].x, points[i].y);
                            ctx.lineTo(points[j].x, points[j].y);
                        }
                    }
                }
                ctx.stroke();

                if (isAI) {
                    ctx.fillStyle = C_CYAN;
                    ctx.font = '12px monospace';
                    ctx.fillText("COVERAGE: 99.9%", 10, 20);
                } else {
                    ctx.fillStyle = '#666';
                    ctx.fillText("COVERAGE: 42.0%", 10, 20);
                }

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 3. STRATA DRILL
        const initDrill = (ctx, w, h) => {
            let depth = 0;
            const layers = [
                { c: '#333', h: 50 }, { c: '#444', h: 80 }, { c: '#222', h: 120 },
                { c: '#555', h: 180 }, { c: '#111', h: 300 }
            ];

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.fillStyle = C_BG;
                ctx.fillRect(0, 0, w, h);

                const speed = isAI ? 5 : 0.5;
                depth += speed;

                let y = 0;
                layers.forEach(l => {
                    const drawY = y - (depth % 300);
                    ctx.fillStyle = l.c;
                    ctx.fillRect(0, drawY, w, l.h);
                    if (Math.random() > 0.8) {
                        ctx.fillStyle = '#000';
                        ctx.fillRect(Math.random() * w, drawY + Math.random() * l.h, 4, 4);
                    }
                    y += l.h;
                });
                y = 0;
                layers.forEach(l => {
                    const drawY = y - (depth % 300) + 300;
                    ctx.fillStyle = l.c;
                    ctx.fillRect(0, drawY, w, l.h);
                    y += l.h;
                });

                const drillW = 20;
                ctx.fillStyle = isAI ? C_PINK : '#888';
                ctx.fillRect(w / 2 - drillW / 2, 0, drillW, h / 2);

                ctx.beginPath();
                ctx.moveTo(w / 2 - drillW, h / 2);
                ctx.lineTo(w / 2 + drillW, h / 2);
                ctx.lineTo(w / 2, h / 2 + 40);
                ctx.fill();

                if (isAI) {
                    ctx.strokeStyle = C_PINK;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(w / 2, h / 2 + 40);
                    ctx.lineTo(w / 2, h);
                    ctx.stroke();

                    ctx.fillStyle = '#fff';
                    for (let i = 0; i < 5; i++) {
                        ctx.fillRect(w / 2 + (Math.random() - 0.5) * 40, h - Math.random() * 20, 2, 2);
                    }
                }

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 4. PARTICLE COLLIDER
        const initCollider = (ctx, w, h) => {
            let particles = [];
            const spawn = () => {
                // Limit particles to prevent explosion
                if (particles.length > 300) return;
                particles.push({ x: 0, y: h / 2, vx: isAI ? 15 : 5, vy: 0, col: C_CYAN, safe: 0 });
                particles.push({ x: w, y: h / 2, vx: isAI ? -15 : -5, vy: 0, col: C_LIME, safe: 0 });
            };

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(0, 0, w, h);

                if (Math.random() < 0.05) spawn();

                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += (Math.random() - 0.5) * 0.5;
                    if (p.safe > 0) p.safe--;

                    ctx.fillStyle = p.col;
                    ctx.fillRect(p.x, p.y, 4, 4);

                    if (p.safe === 0 && Math.abs(p.x - w / 2) < 10 && Math.abs(p.y - h / 2) < 20) {
                        particles.splice(i, 1);
                        if (isAI) {
                            ctx.fillStyle = '#fff';
                            ctx.beginPath(); ctx.arc(w / 2, h / 2, 20, 0, Math.PI * 2); ctx.fill();

                            // Spawn fewer particles, give them safety frames
                            for (let k = 0; k < 3; k++) {
                                if (particles.length > 500) break;
                                particles.push({
                                    x: w / 2, y: h / 2,
                                    vx: (Math.random() - 0.5) * 15, // Higher velocity to escape zone
                                    vy: (Math.random() - 0.5) * 15,
                                    col: C_PINK,
                                    safe: 10 // Safe for 10 frames
                                });
                            }
                        }
                    }
                }
                requestAnimationFrame(loop);
            };
            loop();
        };

        // 5. EVOLUTIONARY GRID
        const initEvo = (ctx, w, h) => {
            const cols = 40; const rows = 20;
            const cs = w / cols;
            let grid = Array(cols * rows).fill(0).map(() => Math.random() > 0.8 ? 1 : 0);

            const loop = () => {
                if (!isRunning(ctx)) return;
                const now = Date.now();

                ctx.fillStyle = C_BG; ctx.fillRect(0, 0, w, h);

                for (let i = 0; i < grid.length; i++) {
                    if (grid[i]) {
                        const x = (i % cols) * cs;
                        const y = Math.floor(i / cols) * cs;
                        ctx.fillStyle = isAI ? `hsl(${Math.random() * 360}, 50%, 50%)` : '#444';
                        ctx.fillRect(x + 1, y + 1, cs - 2, cs - 2);
                    }
                }

                if (isAI || now % 20 === 0) {
                    const newGrid = [...grid];
                    for (let i = 0; i < grid.length; i++) {
                        const n = (grid[i - 1] || 0) + (grid[i + 1] || 0) + (grid[i - cols] || 0) + (grid[i + cols] || 0);
                        if (grid[i] && (n < 2 || n > 3)) newGrid[i] = 0;
                        else if (!grid[i] && n === 3) newGrid[i] = 1;
                        if (Math.random() < (isAI ? 0.05 : 0)) newGrid[i] = 1;
                    }
                    grid = newGrid;
                }

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 6. HARMONIC RESONATOR
        const initResonator = (ctx, w, h) => {
            let t = 0;
            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.clearRect(0, 0, w, h);
                t += 0.1;

                ctx.lineWidth = 2;

                ctx.strokeStyle = '#333';
                ctx.beginPath();
                for (let x = 0; x < w; x += 5) ctx.lineTo(x, h / 2 + Math.sin(x * 0.02 + t) * 30);
                ctx.stroke();

                ctx.strokeStyle = '#444';
                ctx.beginPath();
                const phase = isAI ? 0 : Math.PI;
                for (let x = 0; x < w; x += 5) ctx.lineTo(x, h / 2 + Math.sin(x * 0.02 + t + phase) * 30);
                ctx.stroke();

                ctx.strokeStyle = isAI ? C_LIME : '#555';
                ctx.lineWidth = isAI ? 5 : 1;
                ctx.beginPath();
                for (let x = 0; x < w; x += 5) {
                    const y1 = Math.sin(x * 0.02 + t) * 30;
                    const y2 = Math.sin(x * 0.02 + t + phase) * 30;
                    ctx.lineTo(x, h / 2 + (y1 + y2));
                }
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.fillText(isAI ? "AMPLITUDE: 200% (RIDING THE WAVE)" : "AMPLITUDE: 0% (CANCELLED OUT)", 10, 20);

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 7. RUST SCRUBBER
        const initScrubber = (ctx, w, h) => {
            const cs = 10;
            const cols = Math.ceil(w / cs);
            const grid = Array(cols * Math.ceil(h / cs)).fill(1);
            let sx = 0; let sy = 0;

            const loop = () => {
                if (!isRunning(ctx)) return;

                // Opimization: Don't redraw clean cells if they are just background
                ctx.fillStyle = C_BG;
                ctx.fillRect(0, 0, w, h);

                for (let i = 0; i < grid.length; i++) {
                    const x = (i % cols) * cs;
                    const y = Math.floor(i / cols) * cs;

                    if (grid[i] > 0.1) { // Only draw if dirty
                        ctx.fillStyle = `rgba(120, 80, 40, ${grid[i]})`;
                        ctx.fillRect(x, y, cs, cs);
                    } else if (Math.random() > 0.998) {
                        ctx.fillStyle = '#fff'; ctx.fillRect(x + 2, y + 2, 2, 2);
                    }
                }

                const speed = isAI ? 10 : 1;
                sx += speed;
                if (sx > w) { sx = 0; sy += 40; }
                if (sy > h) sy = 0;

                const idx = Math.floor(sx / cs) + Math.floor(sy / cs) * cols;
                const r = isAI ? 5 : 1;
                for (let dy = -r; dy <= r; dy++) {
                    for (let dx = -r; dx <= r; dx++) {
                        const check = idx + dx + (dy * cols);
                        if (check >= 0 && check < grid.length) grid[check] -= 0.1;
                    }
                }

                ctx.fillStyle = isAI ? C_CYAN : '#888';
                ctx.beginPath(); ctx.arc(sx, sy, isAI ? 30 : 10, 0, Math.PI * 2); ctx.fill();

                if (Math.random() > 0.9) {
                    grid[Math.floor(Math.random() * grid.length)] = 1;
                }

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 8. THREAD WEAVER
        const initWeaver = (ctx, w, h) => {
            let threads = Array(20).fill().map(() => ({
                y: Math.random() * h,
                targetY: Math.random() * h,
                color: `hsl(${Math.random() * 360}, 60%, 50%)`
            }));

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.fillStyle = 'rgba(5,5,5,0.3)';
                ctx.fillRect(0, 0, w, h);

                if (isAI) {
                    threads.forEach((t, i) => t.targetY = (h / 20) * i + 20);
                } else {
                    if (Math.random() > 0.95) threads.forEach(t => t.targetY = Math.random() * h);
                }

                threads.forEach((t, i) => {
                    t.y += (t.targetY - t.y) * 0.05;
                    ctx.strokeStyle = t.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, t.y);
                    for (let x = 0; x < w; x += 10) {
                        ctx.lineTo(x, t.y + Math.sin(x * 0.01 + performance.now() * 0.005) * 5);
                    }
                    ctx.stroke();
                });

                requestAnimationFrame(loop);
            };
            loop();
        };

        // 9. OMNI-LIGHT
        const initLight = (ctx, w, h) => {
            const shapes = [
                { x: w * 0.3, y: h * 0.3, type: 'rect' },
                { x: w * 0.7, y: h * 0.6, type: 'circ' },
                { x: w * 0.5, y: h * 0.8, type: 'tri' }
            ];
            let ang = 0;

            const loop = () => {
                if (!isRunning(ctx)) return;
                ctx.fillStyle = '#111';
                ctx.fillRect(0, 0, w, h);

                ang += 0.01;
                const mx = w / 2 + Math.cos(ang) * (w / 4);
                const my = h / 2 + Math.sin(ang) * (h / 4);

                ctx.fillStyle = '#222';
                shapes.forEach(s => {
                    if (s.type == 'rect') ctx.fillRect(s.x, s.y, 60, 60);
                    else if (s.type == 'circ') { ctx.beginPath(); ctx.arc(s.x, s.y, 40, 0, Math.PI * 2); ctx.fill(); }
                    else { ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x + 40, s.y + 60); ctx.lineTo(s.x - 40, s.y + 60); ctx.fill(); }
                });

                const r = isAI ? 400 : 60;

                ctx.save();
                ctx.beginPath();
                ctx.arc(mx, my, r, 0, Math.PI * 2);
                ctx.clip();

                shapes.forEach(s => {
                    ctx.fillStyle = isAI ? C_LIME : '#fff';
                    if (s.type == 'rect') ctx.fillRect(s.x, s.y, 60, 60);
                    else if (s.type == 'circ') { ctx.beginPath(); ctx.arc(s.x, s.y, 40, 0, Math.PI * 2); ctx.fill(); }
                    else { ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x + 40, s.y + 60); ctx.lineTo(s.x - 40, s.y + 60); ctx.fill(); }
                });
                ctx.restore();

                const g = ctx.createRadialGradient(mx, my, 0, mx, my, r);
                g.addColorStop(0, 'rgba(255,255,255,0.1)');
                g.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, w, h);

                requestAnimationFrame(loop);
            };
            loop();
        };

        // Init
        renderGrid();

    </script>
</body>

</html>